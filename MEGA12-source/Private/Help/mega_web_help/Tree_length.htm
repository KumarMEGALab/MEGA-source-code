<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="OriginalFile" content="Glossary_RH.doc" />
<meta name="generator" content="Adobe RoboHelp 2017" />
<title>Tree length</title>
<link rel="stylesheet" href="Glossary_RH.css" type="text/css" />
 <link rel="StyleSheet" href="default.css" type="text/css" />
<style type="text/css">
<!--
A:visited { color:#800080; }
A:link { color:#0000ff; }
-->
</style>
<script type="text/javascript" language="JavaScript">
//<![CDATA[
function reDo() {
  if (innerWidth != origWidth || innerHeight != origHeight)
     location.reload();
}
if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
	origWidth = innerWidth;
	origHeight = innerHeight;
	onresize = reDo;
}
onerror = null; 
//]]>
</script>
<style type="text/css">
<!--
div.WebHelpPopupMenu { position:absolute;
left:0px;
top:0px;
z-index:4;
visibility:hidden; }
p.WebHelpNavBar { text-align:right; }
-->
</style>

<script type="text/javascript" src="template/scripts/rh.min.js"></script>
<script type="text/javascript" src="template/scripts/common.min.js"></script>
<script type="text/javascript" src="template/scripts/topic.min.js"></script>
<script type="text/javascript" src="template/scripts/constants.js"></script>
<script type="text/javascript" src="template/scripts/utils.js"></script>
<script type="text/javascript" src="template/scripts/mhutils.js"></script>
<script type="text/javascript" src="template/scripts/mhlang.js"></script>
<script type="text/javascript" src="template/scripts/mhver.js"></script>
<script type="text/javascript" src="template/scripts/settings.js"></script>
<script type="text/javascript" src="template/scripts/XmlJsReader.js"></script>
<script type="text/javascript" src="template/scripts/loadparentdata.js"></script>
<script type="text/javascript" src="template/scripts/loadscreen.js"></script>
<script type="text/javascript" src="template/scripts/loadprojdata.js"></script>
<script type="text/javascript" src="template/scripts/mhtopic.js"></script>
 <link rel="stylesheet" type="text/css" href="template/styles/widgets.min.css">
 <link rel="stylesheet" type="text/css" href="template/styles/topic.min.css">
<script type="text/javascript" >
gRootRelPath = ".";
gCommonRootRelPath = ".";
gTopicId = "9.0_75";
</script>
 <meta name="topic-breadcrumbs" content="Glossary" />
</head>

<body>
<script type="text/javascript" src="./ehlpdhtm.js"></script>


<h1>Tree length</h1>
<p><a href="javascript:TextPopup(this)" id="HotSpot51319" class="glossterm">Tree length</a><script type="text/javascript">//<![CDATA[
TextPopupInit('HotSpot51319', 'POPUP51319');
//]]></script><span class="glosstext" id="POPUP51319" style="display: none;"> Tree length is the criterion used by the Maximum Parsimony method to search for the best tree.  It is defined as the sum of the minimum numbers of substitutions over all sites for the given topology.   To compute the tree length for the unweighted parsimony method, we use the procedure described in Fitch (1971), which is based on the two rules described below.  For a given site these rules are applied to each node and the sum of substitutions over all nodes and over all sites are taken.  Note that the estimation of the minimum number of substitutions is not affected by the position of the root.  Rule 1.  When the two descendent nodes of an ancestral node have some states (nucleotides or amino acids) in common, the ancestral node is assigned to the set of common states.  In this case, the most parsimonious explanation does not require any substitutions.  Rule 2.  When the two descendant nodes have no states in common, then all states in the descendent nodes are combined to form the set of possible states at the ancestral node.  In this case, one substitution is required.</span> is the 
 criterion used by the <u style="text-underline: double; color: #007fbf;"><span 
	 style="color: #007fbf;"><a href="Maximum_Parsimony_MP_Method.htm" 
								 style="color: #007fbf;">Maximum Parsimony</a></span></u><span 
	 style="display: none;">HC_Maximum_Parsimony</span> method to search 
 for the best tree.&#160;&#160;It is defined as the sum of the minimum 
 numbers of substitutions over all sites for the given <u><span style="color: #008000;"><a href="javascript:TextPopup(this)" id="HotSpot47184" class="glossterm">topology</a><script type="text/javascript">//<![CDATA[
TextPopupInit('HotSpot47184', 'POPUP47184');
//]]></script><span class="glosstext" id="POPUP47184" style="display: none;"> The branching pattern of a tree is its topology.</span></span></u><span style="display: none;">RH_Topology</span>.</p>
<p>To compute the <a href="javascript:TextPopup(this)" id="HotSpot24084" class="glossterm">tree length</a><script type="text/javascript">//<![CDATA[
TextPopupInit('HotSpot24084', 'POPUP24084');
//]]></script><span class="glosstext" id="POPUP24084" style="display: none;"> Tree length is the criterion used by the Maximum Parsimony method to search for the best tree.  It is defined as the sum of the minimum numbers of substitutions over all sites for the given topology.   To compute the tree length for the unweighted parsimony method, we use the procedure described in Fitch (1971), which is based on the two rules described below.  For a given site these rules are applied to each node and the sum of substitutions over all nodes and over all sites are taken.  Note that the estimation of the minimum number of substitutions is not affected by the position of the root.  Rule 1.  When the two descendent nodes of an ancestral node have some states (nucleotides or amino acids) in common, the ancestral node is assigned to the set of common states.  In this case, the most parsimonious explanation does not require any substitutions.  Rule 2.  When the two descendant nodes have no states in common, then all states in the descendent nodes are combined to form the set of possible states at the ancestral node.  In this case, one substitution is required.</span> 
 for the unweighted parsimony method, we use the procedure described in 
 <u style="color: #007fbf;"><span style="color: #007fbf;"><a href="Fitch_1971.htm" 
															 style="color: #007fbf;">Fitch 
 (1971)</a></span></u><span style="display: none;">Fitch_1971</span>, which 
 is based on the two rules described below.&#160;&#160;For a given site 
 these rules are applied to each <a href="javascript:TextPopup(this)" id="HotSpot41569" class="glossterm">node</a><script type="text/javascript">//<![CDATA[
TextPopupInit('HotSpot41569', 'POPUP41569');
//]]></script><span class="glosstext" id="POPUP41569" style="display: none;"> A node in a phylogenetic tree represents a taxon, the external or terminal nodes represent the extant taxa and the internal nodes represent the ancestral taxa.</span> 
 and the sum of substitutions over all nodes and over all sites are taken.&#160;&#160;Note 
 that the estimation of the minimum number of substitutions is not affected 
 by the position of the root.</p>
<p>Rule 1.&#160;&#160;When the two descendent nodes of an ancestral <a href="javascript:TextPopup(this)" id="HotSpot62376" class="glossterm">node</a><script type="text/javascript">//<![CDATA[
TextPopupInit('HotSpot62376', 'POPUP62376');
//]]></script><span class="glosstext" id="POPUP62376" style="display: none;"> A node in a phylogenetic tree represents a taxon, the external or terminal nodes represent the extant taxa and the internal nodes represent the ancestral taxa.</span> have some states (nucleotides or 
 amino acids) in common, the ancestral <a href="javascript:TextPopup(this)" id="HotSpot18951" class="glossterm">node</a><script type="text/javascript">//<![CDATA[
TextPopupInit('HotSpot18951', 'POPUP18951');
//]]></script><span class="glosstext" id="POPUP18951" style="display: none;"> A node in a phylogenetic tree represents a taxon, the external or terminal nodes represent the extant taxa and the internal nodes represent the ancestral taxa.</span> 
 is assigned to the set of common states.&#160;&#160;In this case, the 
 most parsimonious explanation does not require any substitutions.</p>
<p>Rule 2.&#160;&#160;When the two descendant nodes have no states in common, 
 then all states in the descendent nodes are combined to form the set of 
 possible states at the ancestral <a href="javascript:TextPopup(this)" id="HotSpot33776" class="glossterm">node</a><script type="text/javascript">//<![CDATA[
TextPopupInit('HotSpot33776', 'POPUP33776');
//]]></script><span class="glosstext" id="POPUP33776" style="display: none;"> A node in a phylogenetic tree represents a taxon, the external or terminal nodes represent the extant taxa and the internal nodes represent the ancestral taxa.</span>.&#160;&#160;In 
 this case, one substitution is required.</p>
<p>&#160;</p>
<b><span style="font-size: 10.0pt; font-family: Arial, sans-serif; color: #0000ff;"><br 
	 style="clear: all;" clear="all" />
</span></b> 
</body>
</html>
